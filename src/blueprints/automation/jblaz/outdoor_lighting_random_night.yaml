blueprint:
  name: Outdoor Lights â€“ Independent Random Activity (Label Safe)
  description: Randomly toggles individual outdoor lights overnight
  domain: automation
  input:
    lights:
      name: Outdoor Lights
      description: Select labels, areas, or lights
      selector:
        target: {}
    random_start:
      name: Random Start Time
      default: '23:00:00'
      selector:
        time: {}
    duration_minutes:
      name: Duration (minutes)
      description: How long the random events should continue
      default: 360
      selector:
        number:
          min: 15.0
          max: 600.0
          step: 15.0
          mode: slider
          unit_of_measurement: minutes
    min_events:
      name: Minimum Events
      default: 2
      selector:
        number:
          min: 0.0
          max: 20.0
          step: 1.0
          mode: slider
    max_events:
      name: Maximum Events
      default: 8
      selector:
        number:
          min: 1.0
          max: 30.0
          step: 1.0
          mode: slider
    min_delay:
      name: Minimum Delay (minutes)
      default: 10
      selector:
        number:
          min: 1.0
          max: 180.0
          step: 5.0
          mode: slider
    max_delay:
      name: Maximum Delay (minutes)
      default: 60
      selector:
        number:
          min: 5.0
          max: 240.0
          step: 5.0
          mode: slider

trigger:
  - platform: sun
    event: sunset
    id: sunset
    alias: Sunset
  - platform: time_pattern
    minutes: "/1"
    id: tick
    alias: Minute Tick
  - platform: sun
    event: sunrise
    id: sunrise
    alias: Sunrise

# 1) Bind inputs to variables that can be used in templates.
# 2) Derive helper lists/values using those variables.
variables:
  v_lights: !input lights
  v_random_start: !input random_start
  v_duration_minutes: !input duration_minutes
  v_min_events: !input min_events
  v_max_events: !input max_events
  v_min_delay: !input min_delay
  v_max_delay: !input max_delay

  # Expand selected targets (labels/areas/entities) to a flat list of light entity_ids
  lights_list: >-
    {% set entity_ids = v_lights.get('entity_id', []) %}
    {{ expand(entity_ids)
       | selectattr('domain','eq','light')
       | map(attribute='entity_id')
       | list }}

  # Random count in [min,max]
  event_count: >-
    {{ range((v_min_events | int), (v_max_events | int) + 1) | random }}

  # Calculate end timestamp (start time + duration in minutes)
  sequence_end_time: >-
    {{ now() + timedelta(minutes=(v_duration_minutes | int)) }}

action:
  - choose:
      - conditions:
          - condition: trigger
            id: sunset
        sequence:
          - service: light.turn_on
            target: !input lights

      - conditions:
          - condition: trigger
            id: tick
          - condition: template
            value_template: '{{ lights_list | length > 0 }}'
          - condition: template
            value_template: >-
              {{ now().strftime('%H:%M:%S') == v_random_start }}
        sequence:
          - service: automation.turn_on
            target:
              entity_id: this.entity_id
          - service: persistent_notification.create
            data:
              title: "ðŸŒ™ Random Lighting Sequence Started"
              message: >-
                Events scheduled: {{ event_count }}
                Duration: {{ v_duration_minutes }} minutes
                Sequence end time: {{ (now() + timedelta(minutes=(v_duration_minutes | int))).strftime('%H:%M:%S') }}
          - repeat:
              count: '{{ event_count }}'
              sequence:
                # Stop if we've exceeded the duration
                - condition: template
                  value_template: '{{ now() < sequence_end_time }}'
                # Calculate random delay for this event
                - variables:
                    delay_minutes: >-
                      {{ range((v_min_delay | int), (v_max_delay | int) + 1) | random }}
                    next_toggle_time: >-
                      {{ (now() + timedelta(minutes=(delay_minutes | int))).strftime('%H:%M:%S') }}
                    selected_light: '{{ (lights_list | default([], true)) | random }}'
                # Show what's about to happen
                - service: persistent_notification.create
                  data:
                    title: "â±ï¸ Event {{ repeat.index }} of {{ event_count }}"
                    message: >-
                      Delay: {{ delay_minutes }} minutes
                      Will toggle at: {{ next_toggle_time }}
                      Light: {{ state_attr(selected_light, 'friendly_name') | default(selected_light) }}
                # Apply the delay
                - delay:
                    minutes: '{{ delay_minutes }}'
                # Stop any remaining steps if we've reached sunrise or exceeded duration
                - condition: template
                  value_template: '{{ now() < sequence_end_time }}'
                - condition: sun
                  before: sunrise
                # Toggle the selected light
                - service: light.toggle
                  target:
                    entity_id: '{{ selected_light }}'
                - service: persistent_notification.create
                  data:
                    title: "ðŸ’¡ Toggled Light {{ repeat.index }} of {{ event_count }}"
                    message: >-
                      Light: {{ state_attr(selected_light, 'friendly_name') | default(selected_light) }}
                      New state: {{ states(selected_light) | upper }}
          # After sequence completes or duration expires, turn on all lights
          - service: light.turn_on
            target: !input lights

      - conditions:
          - condition: trigger
            id: sunrise
        sequence:
          - service: light.turn_off
            target: !input lights

mode: restart
